/*
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
** $Date$ $Revision$
** $Header: //depot/main/gfx/lib/opengl/glcore/s_pgclip.c#8 $
*/
#include <math.h>
#include "context.h"
#include "global.h"

#define __GL_COPY_FLAGBITS(dst, src) \
  (dst->flagBits = (dst->flagBits & __GL_CLIP_MASK) | \
   (src->flagBits & ~__GL_CLIP_MASK))

/*
** Clip an input polygon against a clipping plane outputing the new
** vertex pointers in ov and return the number of them.  See the line
** clipping code for an in depth discussion of how "t" is computed.
**
** NOTE: In order to handle non-convex polygons here without dying,
** we count the number of verticies generated by clipping.  If the
** count ever gets to 3, then it must be a non-convex polygon (because
** it means the polygon crossed the clipping plane three times, which is
** impossible for a convex polygon).
*/
static GLint clipToPlane(__GLcontext *gc, __GLvertex **iv, GLint niv,
			 __GLvertex **ov, __GLcoord *plane)
{
    GLint i, nout, generated;
    __GLvertex *s, *p, *newVertex, *temp;
    __GLfloat pDist, sDist, t;
    __GLfloat zero = __glZero;
    void (*clip)(__GLvertex*, const __GLvertex*, const __GLvertex*, __GLfloat);

    nout = 0;
    generated = 0;
    temp = gc->transform.nextClipTemp;
    clip = gc->procs.polyClipParam;

    s = iv[niv-1];
    sDist = (s->clip.x * plane->x) + (s->clip.y * plane->y) +
	    (s->clip.z * plane->z) + (s->clip.w * plane->w);
    for (i = 0; i < niv; i++) {
	p = iv[i];
	pDist = (p->clip.x * plane->x) + (p->clip.y * plane->y) +
		(p->clip.z * plane->z) + (p->clip.w * plane->w);
	if (pDist >= zero) {
	    /* p is inside the clipping plane half space */
	    if (sDist >= zero) {
		/* s is inside the clipping plane half space */
		*ov++ = p;
		nout++;
	    } else {
		/* s is outside the clipping plane half space */
		t = (pDist - sDist) ? pDist / (pDist - sDist) : __glZero;
		newVertex = temp++;
		(*clip)(newVertex, s, p, t);
		__GL_COPY_FLAGBITS(newVertex, s);
		assert(newVertex->color == &newVertex->colors[__GL_FRONTFACE]);
		*ov++ = newVertex;
		*ov++ = p;
		nout += 2;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    }
	} else {
	    /* p is outside the clipping plane half space */
	    if (sDist >= zero) {
		/*
		** s is inside the clipping plane half space
		**
		** NOTE: To avoid cracking in polygons with shared
		** clipped edges we always compute "t" from the out
		** vertex to the in vertex.  The above clipping code gets
		** this for free (p is in and s is out).  In this code p
		** is out and s is in, so we reverse the t computation
		** and the argument order to __glDoClip.
		*/
		t = (sDist - pDist) ? sDist / (sDist - pDist) : __glZero;
		newVertex = temp++;
		(*clip)(newVertex, p, s, t);
		__GL_COPY_FLAGBITS(newVertex, s);
		assert(newVertex->color == &newVertex->colors[__GL_FRONTFACE]);
		*ov++ = newVertex;
		nout++;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    } else {
		/* both points are outside */
	    }
	}
	s = p;
	sDist = pDist;
    }
    gc->transform.nextClipTemp = temp;
    return nout;
}

/* 
** Identical to clipToPlane(), except that the clipping is done in eye
** space.
*/
static GLint clipToPlaneEye(__GLcontext *gc, __GLvertex **iv, GLint niv,
			    __GLvertex **ov, __GLcoord *plane)
{
    GLint i, nout, generated;
    __GLvertex *s, *p, *newVertex, *temp;
    __GLfloat pDist, sDist, t;
    __GLfloat zero = __glZero;
    void (*clip)(__GLvertex*, const __GLvertex*, const __GLvertex*, __GLfloat);

    nout = 0;
    generated = 0;
    temp = gc->transform.nextClipTemp;
    clip = gc->procs.polyClipParam;

    s = iv[niv-1];
    sDist = (s->eye.x * plane->x) + (s->eye.y * plane->y) +
	    (s->eye.z * plane->z) + (s->eye.w * plane->w);
    for (i = 0; i < niv; i++) {
	p = iv[i];
	pDist = (p->eye.x * plane->x) + (p->eye.y * plane->y) +
		(p->eye.z * plane->z) + (p->eye.w * plane->w);
	if (pDist >= zero) {
	    /* p is inside the clipping plane half space */
	    if (sDist >= zero) {
		/* s is inside the clipping plane half space */
		*ov++ = p;
		nout++;
	    } else {
		/* s is outside the clipping plane half space */
		t = (pDist - sDist) ? pDist / (pDist - sDist) : __glZero;
		newVertex = temp++;
		(*clip)(newVertex, s, p, t);
		newVertex->eye.x = t*(s->eye.x - p->eye.x) + p->eye.x;
		newVertex->eye.y = t*(s->eye.y - p->eye.y) + p->eye.y;
		newVertex->eye.z = t*(s->eye.z - p->eye.z) + p->eye.z;
		newVertex->eye.w = t*(s->eye.w - p->eye.w) + p->eye.w;
		__GL_COPY_FLAGBITS(newVertex, s);
		assert(newVertex->color == &newVertex->colors[__GL_FRONTFACE]);
		*ov++ = newVertex;
		*ov++ = p;
		nout += 2;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    }
	} else {
	    /* p is outside the clipping plane half space */
	    if (sDist >= zero) {
		/*
		** s is inside the clipping plane half space
		**
		** NOTE: To avoid cracking in polygons with shared
		** clipped edges we always compute "t" from the out
		** vertex to the in vertex.  The above clipping code gets
		** this for free (p is in and s is out).  In this code p
		** is out and s is in, so we reverse the t computation
		** and the argument order to __glDoClip.
		*/
		t = (sDist - pDist) ? sDist / (sDist - pDist) : __glZero;
		newVertex = temp++;
		(*clip)(newVertex, p, s, t);
		newVertex->eye.x = t*(p->eye.x - s->eye.x) + s->eye.x;
		newVertex->eye.y = t*(p->eye.y - s->eye.y) + s->eye.y;
		newVertex->eye.z = t*(p->eye.z - s->eye.z) + s->eye.z;
		newVertex->eye.w = t*(p->eye.w - s->eye.w) + s->eye.w;
		__GL_COPY_FLAGBITS(newVertex, s);
		assert(newVertex->color == &newVertex->colors[__GL_FRONTFACE]);
		*ov++ = newVertex;
		nout++;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    } else {
		/* both points are outside */
	    }
	}
	s = p;
	sDist = pDist;
    }
    gc->transform.nextClipTemp = temp;
    return nout;
}

/*
** Each clipping plane can add at most one vertex to a convex polygon (it may
** remove up to all of the verticies).  The clipping will leave a polygon
** convex.  Because of this the maximum number of verticies output from
** the clipToPlane procedure will be total number of clip planes (assuming
** each plane adds one new vertex) plus the original number of verticies
** (3 since this if for triangles).
*/
#define	__GL_MAX_CLIP_VERTEX (__GL_MAX_CLIP_PLANES + __GL_NVBUF)

void __glDoPolygonClip(__GLcontext *gc, __GLvertex **iv, GLint nout,
		       GLuint allClipCodes)
{
    __GLvertex *ov[__GL_MAX_CLIP_PLANES][__GL_MAX_CLIP_VERTEX];
    __GLvertex **ivp;
    __GLvertex **ovp;
    __GLvertex *p0, *p1, *p2;
    __GLcoord *plane;
    GLint i;
    __GLviewport *vp;
    __GLfloat vpXScale, vpYScale, vpZScale;
    __GLfloat vpXCenter, vpYCenter, vpZCenter;
    __GLfloat llx, lly, urx, ury;
    __GLfloat winx, winy;
    GLuint clipCodes;
    GLuint needs = gc->vertex.faceNeeds[__GL_FRONTFACE] |
	    gc->vertex.faceNeeds[__GL_BACKFACE] | __GL_HAS_CLIP;
    
    allClipCodes &= __GL_CLIP_MASK;
    allClipCodes >>= __GL_CLIP_SHIFT;

    /*
    ** Reset nextClipTemp pointer for any new verticies that are generated
    ** during the clipping.
    */
    gc->transform.nextClipTemp = gc->transform.clipTemp;

    ivp = &iv[0];

    /*
    ** Check each of the clipping planes by examining the allClipCodes
    ** mask. Note that no bits will be set in allClipCodes for clip
    ** planes that are not enabled.
    */
    if (allClipCodes) {
	/* Validate vertex data before clipping */
	ovp = ivp;
	for (i = nout; --i >= 0; ) {
	    __GLvertex *vx = *ovp++;
	    if (~vx->flagBits & needs) DO_VALIDATE(gc, vx, needs);
	}

	/* Now clip against the clipping planes */
	ovp = &ov[0][0];

	/* 
	** Do user clip planes first, because we will maintain eye coordinates
	** only while doing user clip planes.  They are ignored for the 
	** frustum clipping planes.
	*/
	clipCodes = allClipCodes >> 6;
	if (clipCodes) {
	    plane = &gc->state.transform.eyeClipPlanes[0];
	    do {
		if (clipCodes & (__GL_CLIP_LEFT >> __GL_CLIP_SHIFT)) {
		    nout = clipToPlaneEye(gc, ivp, nout, ovp, plane);
		    if (nout < 3) {
			return;
		    }
		    ivp = ovp;
		    ovp += __GL_MAX_CLIP_VERTEX;
		}
		clipCodes >>= 1;
		plane++;
	    } while (clipCodes);
	}

	allClipCodes &= (__GL_CLIP_FRUSTUM_MASK >> __GL_CLIP_SHIFT);
	if (allClipCodes) {
	    plane = &__gl_frustumClipPlanes[0];
	    do {
		if (allClipCodes & (__GL_CLIP_LEFT >> __GL_CLIP_SHIFT)) {
		    nout = clipToPlane(gc, ivp, nout, ovp, plane);
		    if (nout < 3) {
			return;
		    }
		    ivp = ovp;
		    ovp += __GL_MAX_CLIP_VERTEX;
		}
		allClipCodes >>= 1;
		plane++;
	    } while (allClipCodes);
	}

	/*
	** Calculate final screen coordinates.  Next phase of polygon
	** processing assumes that window coordinates are already computed.
	*/
	vp = &gc->state.viewport;
	vpXCenter = vp->xCenter;
	vpYCenter = vp->yCenter;
	vpZCenter = vp->zCenter;
	vpXScale = vp->xScale;
	vpYScale = vp->yScale;
	vpZScale = vp->zScale;
	ovp = ivp;

	llx = vpXCenter - vpXScale;
	urx = vpXCenter + vpXScale;
	if (vpYScale > 0) {
	    lly = vpYCenter - vpYScale;
	    ury = vpYCenter + vpYScale;
	} else {
	    lly = vpYCenter + vpYScale;
	    ury = vpYCenter - vpYScale;
	}

	for (i = nout; --i >= 0; ) {
	    __GLfloat x, y, z, wInv;

	    p0 = *ovp++;

	    wInv = p0->clip.w ? __glOne / p0->clip.w : __glZero;
	    x = p0->clip.x; y = p0->clip.y; z = p0->clip.z;
	    winx = x * vpXScale * wInv + vpXCenter;
	    winy = y * vpYScale * wInv + vpYCenter;
	    p0->window.z = z * vpZScale * wInv + vpZCenter;
	    p0->window.w = wInv;
	    /* 
	    ** Check if these window coordinates are legal.  At this 
	    ** point, it is quite possible that they are not.  Trivially
	    ** pull them into the legal viewport region if necessary.
	    */
	    if (winx < llx) winx = llx;
	    else if (winx > urx) winx = urx;
	    if (winy < lly) winy = lly;
	    else if (winy > ury) winy = ury;
	    p0->window.x = winx;
	    p0->window.y = winy;
	    if ((p0->flagBits & __GL_CLIP_MASK) &&
		gc->polygon.shader.modeFlags & __GL_SHADE_PROJSCALED_TEXTURE) {
		p0->texture[0].x *= p0->window.w;
		p0->texture[0].y *= p0->window.w;
		p0->texture[0].w *= p0->window.w;
	    }
	}
    }

    /*
    ** Subdivide the clipped polygon into triangles.  Only convex polys
    ** are supported so this is okay to do.  Non-convex polys will do
    ** something odd here, but thats the clients fault.
    */
    p0 = *ivp++;
    p1 = *ivp++;
    p2 = *ivp++;
    if (nout == 3) {
	(*gc->procs.renderTriangle)(gc, p0, p1, p2);
    } else {
	for (i = 0; i < nout - 2; i++) {
	    GLuint t1, t2;
	    if (i == 0) {
		/*
		** Third edge of first sub-triangle is always non-boundary
		*/
		t1 = p2->flagBits & __GL_VERTEX_EDGE_FLAG;
		p2->flagBits &= ~__GL_VERTEX_EDGE_FLAG;
		(*gc->procs.renderTriangle)(gc, p0, p1, p2);
		p2->flagBits |= t1;
	    } else
	    if (i == nout - 3) {
		/*
		** First edge of last sub-triangle is always non-boundary
		*/
		t1 = p0->flagBits & __GL_VERTEX_EDGE_FLAG;
		p0->flagBits &= ~__GL_VERTEX_EDGE_FLAG;
		(*gc->procs.renderTriangle)(gc, p0, p1, p2);
		p0->flagBits |= t1;
	    } else {
		/*
		** Interior sub-triangles have the first and last edge
		** marked non-boundary
		*/
		t1 = p0->flagBits & __GL_VERTEX_EDGE_FLAG;
		t2 = p2->flagBits & __GL_VERTEX_EDGE_FLAG;
		p0->flagBits &= ~__GL_VERTEX_EDGE_FLAG;
		p2->flagBits &= ~__GL_VERTEX_EDGE_FLAG;
		(*gc->procs.renderTriangle)(gc, p0, p1, p2);
		p0->flagBits |= t1;
		p2->flagBits |= t2;
	    }
	    p1 = p2;
	    p2 = (__GLvertex *) *ivp++;
	}
    }
}

void __glClipPolygon(__GLcontext *gc, __GLvertex *v0, GLint nv)
{
    __GLvertex *iv[__GL_NVBUF];
    __GLvertex **ivp;
    GLint i;
    GLuint andCodes, orCodes;

    gc->vertex.provoking = v0;

    /*
    ** Generate array of addresses of the verticies.  And all the
    ** clip codes together while we are at it.
    */
    ivp = &iv[0];
    andCodes = ~0;
    orCodes = 0;
    for (i = nv; --i >= 0; ) {
	andCodes &= v0->flagBits;
	orCodes |= v0->flagBits;
	*ivp++ = v0++;
    }

    if ((andCodes & __GL_CLIP_MASK) != 0) {
	/*
	** Trivially reject the polygon.  If andCodes is non-zero then
	** every vertex in the polygon is outside of the same set of
	** clipping planes (at least one).
	*/
	return;
    }
    __glDoPolygonClip(gc, &iv[0], nv, orCodes & __GL_CLIP_MASK);
}

void __glClipTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
		      __GLvertex *c, GLuint orCodes)
{
    __GLvertex *iv[3];

    iv[0] = a;
    iv[1] = b;
    iv[2] = c;
    __glDoPolygonClip(gc, &iv[0], 3, orCodes);
}

/************************************************************************/

void __glCalc2DOutcode(__GLcontext *gc, __GLclipVertex *cv,
		       __GLregionRect *rect)
{
    __GLfloat x = cv->v.window.x;
    __GLfloat y = cv->v.window.y;
    GLuint code = 0;

#if defined(__GL_HALF_PIXEL_OFFSET)
    x -= 0.5f,
    y -= 0.5f;
#endif /* __GL_HALF_PIXEL_OFFSET */

#if __GL_ALIGNED_BUFFERS
    if (x < (float)rect->x0 + gc->constants.fviewportXAdjustOffset)
	code |= __GL_CLIP_LEFT;
    if (x > (float)rect->x1 + gc->constants.fviewportXAdjustOffset)
	code |= __GL_CLIP_RIGHT;
    if (y < (float)rect->y0 + gc->constants.fviewportYAdjustOffset)
	code |= __GL_CLIP_TOP;
    if (y > (float)rect->y1 + gc->constants.fviewportYAdjustOffset)
	code |= __GL_CLIP_BOTTOM;
#else /* __GL_ALIGNED_BUFFERS */
    if (x < (float)rect->x0 + gc->constants.fviewportXAdjust)
	code |= __GL_CLIP_LEFT;
    if (x > (float)rect->x1 + gc->constants.fviewportXAdjust)
	code |= __GL_CLIP_RIGHT;
    if (y < (float)rect->y0 + gc->constants.fviewportYAdjust)
	code |= __GL_CLIP_TOP;
    if (y > (float)rect->y1 + gc->constants.fviewportYAdjust)
	code |= __GL_CLIP_BOTTOM;
#endif /* __GL_ALIGNED_BUFFERS */

    cv->outcode = code;
}

void __glClipAndRenderTriangle(__GLcontext *gc,
			       __GLvertex *v0,
			       __GLvertex *v1,
			       __GLvertex *v2)
{
    __GLdrawablePrivate *dp = gc->drawablePrivate;
    __GLdrawableRegion *glRegion;
    __GLregionRect *rect;

    /*
    ** We need to lock before we get the cliprect, since it may change
    ** while rendering.  This is bad, since the actual triangle routine
    ** may be using the hw to render, but we can argue that the hardware
    ** is broken for not being able to handle this.
    */
    __GL_LOCK_DP(dp, gc);

    glRegion = &dp->ownershipRegion;
    rect = &glRegion->rects[0];

    /* In the common case, no clipping is necessary. */
    if (1 == glRegion->numRects &&
	gc->transform.reasonableViewport &&
#ifdef __GL_ALIGNED_BUFFERS
	rect->x0 == gc->transform.clipX0 - gc->constants.viewportXAdjustOffset &&
	rect->x1 == gc->transform.clipX1 - gc->constants.viewportXAdjustOffset &&
	rect->y0 == gc->transform.clipY0 - gc->constants.viewportYAdjustOffset &&
	rect->y1 == gc->transform.clipY1 - gc->constants.viewportYAdjustOffset
#else
	rect->x0 == gc->transform.clipX0 - gc->constants.viewportXAdjust &&
	rect->x1 == gc->transform.clipX1 - gc->constants.viewportXAdjust &&
	rect->y0 == gc->transform.clipY0 - gc->constants.viewportYAdjust &&
	rect->y1 == gc->transform.clipY1 - gc->constants.viewportYAdjust
#endif
	) {
	(*gc->procs.renderTriangle2)(gc, v0, v1, v2);
	__GL_UNLOCK_DP(dp);
	return;
    }

    /* 
    ** We must have validated vertices to work with, so we have to do
    ** the same work as triangle setup.
    ** Note that we take a pessimistic view of what we'll need.  We could
    ** probably do better in the double sided case here...
    */
    {
	GLuint needs = gc->vertex.faceNeeds[__GL_FRONTFACE] |
	    gc->vertex.faceNeeds[__GL_BACKFACE];

	if (~v0->flagBits & needs) DO_VALIDATE(gc, v0, needs);
	if (~v1->flagBits & needs) DO_VALIDATE(gc, v1, needs);
	if (~v2->flagBits & needs) DO_VALIDATE(gc, v2, needs);
    }

    /* Now clip to each region in the list in turn. */
    {
	__GLclipVertex cv[3+8];		/* Can add 2 vertices per clip edge */
	int i;
	
	cv[0].v = *v0;
	cv[1].v = *v1;
	cv[2].v = *v2;

	for (i = 0; i < glRegion->numRects; i++) {
	    int j;

	    rect = &glRegion->rects[i];

	    /* Generate outcodes for vertices */
	    for (j = 0; j < 3; j++)
		__glCalc2DOutcode(gc, &cv[j], rect);

	    if ((cv[0].outcode | cv[1].outcode | cv[2].outcode) == 0) {
		/* Fully visible. Just draw it. */

		(*gc->procs.renderTriangle2)(gc, v0, v1, v2);

	    } else if ((cv[0].outcode & cv[1].outcode & cv[2].outcode) == 0) {
		/* Partially visible.  Have to do a 2D clip. */

		__GLclipVertex *polygon[2][7];
		int polygon_vertices, next_polygon_vertices;
		int current, next;	/* double-buffer 'polygon', above */
		int nvi;		/* new vertex index into 'cv' */
		void (*clip)(__GLvertex*, const __GLvertex*, const __GLvertex*, __GLfloat);
		static const GLuint edge_flags[] = { __GL_CLIP_LEFT, 
						     __GL_CLIP_RIGHT,
						     __GL_CLIP_TOP,
						     __GL_CLIP_BOTTOM
		};
		int tour;

		clip = gc->procs.polyClipParam;

		polygon_vertices = 3;
		polygon[0][0] = &cv[0];
		polygon[0][1] = &cv[1];
		polygon[0][2] = &cv[2];
		
		current = 0;
		next = 1;
		nvi = 3;	/* after first three vertices */

		for (tour = 0; tour < 4; tour++) {
		    next_polygon_vertices = 0;
		    for (j = 0; j < polygon_vertices; j++) {
			__GLclipVertex *a, *b;
			GLboolean reversed = GL_FALSE;

			if (!(polygon[current][j]->outcode & edge_flags[tour])) {
			    polygon[next][next_polygon_vertices++] = 
				polygon[current][j];
			}

			a = polygon[current][j];
			b = polygon[current][(j + 1) % polygon_vertices];

			/* To guarantee consistency across shared edges, we always
			 * clip in the same direction.  To do this, we impose a strict
			 * ordering on a and b.
			 */
			if ((a->v.window.x < b->v.window.x) ||
			    ((a->v.window.x == b->v.window.x) && (a->v.window.y < b->v.window.y))) {
			    __GLclipVertex *temp;

			    temp = a;
			    a = b;
			    b = temp;
			    reversed = GL_TRUE;
			}

			if ((a->outcode ^ b->outcode) & edge_flags[tour]) {
			    __GLclipVertex *newVertex;
			    __GLfloat edge = __glZero, t;

			    newVertex = &cv[nvi++];
			    newVertex->v.color = &newVertex->v.colors[__GL_FRONTFACE];

			    switch (tour) {
			    case 0:
				edge = (__GLfloat)rect->x0;
#ifdef __GL_ALIGNED_BUFFERS
				edge += gc->constants.fviewportXAdjustOffset;
#else /* __GL_ALIGNED_BUFFERS */
				edge += gc->constants.fviewportXAdjust;
#endif /* __GL_ALIGNED_BUFFERS */
				break;
			    case 1:
				edge = (__GLfloat)rect->x1;
#ifdef __GL_ALIGNED_BUFFERS
				edge += gc->constants.fviewportXAdjustOffset;
#else /* __GL_ALIGNED_BUFFERS */
				edge += gc->constants.fviewportXAdjust;
#endif /* __GL_ALIGNED_BUFFERS */
				break;
			    case 2:
				edge = (__GLfloat)rect->y0;
#ifdef __GL_ALIGNED_BUFFERS
				edge += gc->constants.fviewportYAdjustOffset;
#else /* __GL_ALIGNED_BUFFERS */
				edge += gc->constants.fviewportYAdjust;
#endif /* __GL_ALIGNED_BUFFERS */
				break;
			    case 3:
				edge = (__GLfloat)rect->y1;
#ifdef __GL_ALIGNED_BUFFERS
				edge += gc->constants.fviewportYAdjustOffset;
#else /* __GL_ALIGNED_BUFFERS */
				edge += gc->constants.fviewportYAdjust;
#endif /* __GL_ALIGNED_BUFFERS */
				break;
			    }
#if defined(__GL_HALF_PIXEL_OFFSET)
			    edge += __glHalf;
#endif /* __GL_HALF_PIXEL_OFFSET */

			    if (tour < 2) {
				__GLfloat dx = b->v.window.x - a->v.window.x;
				t = dx ? (b->v.window.x - edge) / dx : __glZero;
				newVertex->v.window.x = edge;
				newVertex->v.window.y = 
				    b->v.window.y + t * (a->v.window.y - b->v.window.y);
			    } else {
				__GLfloat dy = b->v.window.y - a->v.window.y;
				t = dy ? (b->v.window.y - edge) / dy : __glZero;
				newVertex->v.window.x = 
				    b->v.window.x + t * (a->v.window.x - b->v.window.x);
				newVertex->v.window.y = edge;
			    }
			    newVertex->v.window.z = 
				b->v.window.z + t * (a->v.window.z - b->v.window.z);

			    (*clip)(&newVertex->v, &a->v, &b->v, t);

			    /* XXX redo texture since it might have been messed up by clip() */
			    newVertex->v.texture[0].x = b->v.texture[0].x + t * (a->v.texture[0].x - b->v.texture[0].x);
			    newVertex->v.texture[0].y = b->v.texture[0].y + t * (a->v.texture[0].y - b->v.texture[0].y);
			    newVertex->v.texture[0].w = b->v.texture[0].w + t * (a->v.texture[0].w - b->v.texture[0].w);

			    /* copy the boundary flag if we are entering, set it if we are leaving */
			    if (!reversed && (a->outcode & edge_flags[tour])) {
				/* copy a flags & a edge flag */
				newVertex->v.flagBits = a->v.flagBits;
			    } else if (reversed && (b->outcode & edge_flags[tour])) {
				/* copy a flags & b edge flag */
				newVertex->v.flagBits = (a->v.flagBits & ~__GL_VERTEX_EDGE_FLAG) | (b->v.flagBits & __GL_VERTEX_EDGE_FLAG);
			    } else {
				/* copy a flags & clear edge flag */
				newVertex->v.flagBits = a->v.flagBits & ~__GL_VERTEX_EDGE_FLAG;
			    }

			    __glCalc2DOutcode(gc, newVertex, rect);
			    newVertex->outcode &= ~edge_flags[tour];

			    polygon[next][next_polygon_vertices++] = newVertex;
			}
		    }
		    /* There's a new polygon; swap the buffers */
		    polygon_vertices = next_polygon_vertices;
		    current ^= 1;
		    next ^= 1;
		}

		/* Draw the resulting polygon */
		if (polygon_vertices == 3) {
		    (*gc->procs.renderTriangle2)(gc, 
						 &polygon[current][0]->v, 
						 &polygon[current][1]->v, 
						 &polygon[current][2]->v);
		} else {
		    __GLclipVertex **ivp;
		    __GLvertex *p0, *p1, *p2;

		    /* This code lifted from s_pgclip.c - JCB */
		    ivp = &polygon[current][0];
		    p0 = &(*ivp++)->v;
		    p1 = &(*ivp++)->v;
		    p2 = &(*ivp++)->v;

		    for (j = 0; j < (polygon_vertices - 2); j++) {
			GLuint t1, t2;
			if (j == 0) {
			    /*
			    ** Third edge of first sub-triangle is always non-boundary
			    */
			    t1 = p2->flagBits & __GL_VERTEX_EDGE_FLAG;
			    p2->flagBits &= ~__GL_VERTEX_EDGE_FLAG;
			    (*gc->procs.renderTriangle2)(gc, p0, p1, p2);
			    p2->flagBits |= t1;
			} else
			    if (j == (polygon_vertices - 3)) {
				/*
				** First edge of last sub-triangle is always non-boundary
				*/
				t1 = p0->flagBits & __GL_VERTEX_EDGE_FLAG;
				p0->flagBits &= ~__GL_VERTEX_EDGE_FLAG;
				(*gc->procs.renderTriangle2)(gc, p0, p1, p2);
				p0->flagBits |= t1;
			    } else {
				/*
				** Interior sub-triangles have the first and last edge
				** marked non-boundary
				*/
				t1 = p0->flagBits & __GL_VERTEX_EDGE_FLAG;
				t2 = p2->flagBits & __GL_VERTEX_EDGE_FLAG;
				p0->flagBits &= ~__GL_VERTEX_EDGE_FLAG;
				p2->flagBits &= ~__GL_VERTEX_EDGE_FLAG;
				(*gc->procs.renderTriangle2)(gc, p0, p1, p2);
				p0->flagBits |= t1;
				p2->flagBits |= t2;
			    }
			p1 = p2;
			p2 = &(*ivp++)->v;
		    }
		}
	    }
	}
    }

    __GL_UNLOCK_DP(dp);
}

